LLM驱动的文字冒险游戏：Agent开发计划 (1.14版)核心技术栈: Gemini API (文本模型: Gemini 2.5系列, 图像模型: imagen-3.0-generate-002)主要语言: 中文阶段 1: 核心引擎、API密钥管理与基础UI框架搭建目标: 建立游戏的基础架构，实现API密钥的安全管理和基本的用户输入界面。详细任务:游戏引擎 (GameEngine) 核心职责实现:实现中央控制单元功能，负责宏观和微观游戏世界状态的初步管理。建立基础的游戏循环逻辑占位。API密钥管理器 (ApiKeyManager) 模块实现:requestApiKey(): 提示UI显示API密钥输入界面。storeApiKey(apiKey): 会话期间临时安全存储API密钥。validateApiKey(apiKey): 通过调用Gemini API (例如 listModels) 验证密钥有效性。getApiKey(): 返回已存储的API密钥。用户界面 (UIManager) 模块初步实现:showApiKeyScreen(): 实现API密钥输入的UI界面。displayMessage(message, type): 实现向用户显示信息（如错误、提示）的基础UI功能。GameController 模块初步集成:协调 ApiKeyManager 和 UIManager 进行API密钥的请求和验证流程。阶段 2: 模型选择与初始冒险设置目标: 实现文本生成模型的选择功能，并允许Agent根据初步设定定制冒险。详细任务:模型选择器 (ModelSelector) 模块实现:fetchAvailableModels(apiKey): 调用Gemini API列出apiKey可访问的Gemini 2.5系列文本模型。displayModels(modelList): 提示UI显示可选模型列表。setSelectedModel(modelId): 存储Agent选择的文本模型ID (图像模型固定为 imagen-3.0-generate-002)。getSelectedModel(): 返回已选择的文本模型ID。冒险设置 (AdventureSetup) 模块初步实现:requestAdventurePreference(): 提示UI供Agent输入大致的冒险类型描述。用户界面 (UIManager) 模块扩展:showModelSelectionScreen(models): 实现模型选择的UI界面。showAdventurePreferenceScreen(): 实现冒险偏好输入的UI界面。GameController 模块集成:在API密钥验证成功后，调用 ModelSelector 获取并展示模型。在模型选择后，调用 AdventureSetup 请求冒险偏好。阶段 3: “详细世界生成蓝图”的创建目标: 实现通过第一次LLM调用，根据Agent的偏好和引擎指南生成详细的世界生成指令。详细任务:LLM接口 (LLMInterface) 模块初步实现:generate(prompt, modelId, apiKey, contextHistory, expectedResponseType): 实现基础的文本生成函数，针对Gemini 2.5系列模型。负责格式化prompt，处理API调用和错误，解析响应。expectedResponseType 初始可为 'detailed_world_blueprint'。冒险设置 (AdventureSetup) 模块核心功能实现:generateDetailedWorldBlueprint(playerAdventurePreference, engineGuidelines, modelId, apiKey):构建第一次LLM调用的prompt，包含Agent偏好、引擎结构指南、主题元素等。指示LLM生成“详细世界生成蓝图”。调用 LLMInterface.generate()。解析LLM响应，提取“详细世界生成蓝图”。GameController 模块集成:在获取冒险偏好后，调用 AdventureSetup.generateDetailedWorldBlueprint()。向UI显示生成蓝图过程的提示信息。阶段 4: “世界构想文档”生成与GWHR初始化目标: 实现通过第二次LLM调用，使用“详细世界生成蓝图”生成完整的“世界构想文档”，并初始化游戏世界历史记录器。详细任务:冒险设置 (AdventureSetup) 模块扩展:generateInitialWorld(detailedWorldBlueprint, modelId, apiKey):构建第二次LLM调用的prompt，主要包含“详细世界生成蓝图”。指示LLM生成完整的“世界构想文档”（如项目计划3.2节所述）。指定期望的输出结构 (例如JSON)。调用 LLMInterface.generate()，expectedResponseType 可为 'world_conception_document'。解析LLM响应（世界构想文档）。游戏世界历史记录器 (GameWorldHistoryRecorder - GWHR) 模块实现:DataStore: 内部数据结构（例如复杂的JSON对象或结构化数据类集合）。initialize(initialWorldData): 使用从“世界构想文档”解析的数据填充 DataStore。updateState(updates): 实现合并LLM响应更新到 DataStore 的基础逻辑。getCurrentContext(granularity, contextType): 实现序列化 DataStore 相关部分为LLM prompt提供上下文的基础逻辑。GameController 模块集成:在成功生成“详细世界生成蓝图”后，调用 AdventureSetup.generateInitialWorld()。调用 GWHR.initialize()。向UI显示世界生成过程的提示信息。阶段 5: 基础游戏循环、场景呈现（仅文本）与Agent输入处理目标: 建立核心游戏循环，实现基于文本的场景描述和基础的Agent行为选择。详细任务:GameController 模块核心游戏循环逻辑实现:startGame(): 启动游戏，调用 AdventureSetup 流程，然后调用 initiateScene()。advanceTime(duration): 处理游戏内时间推进的基础逻辑，更新GWHR中的全局时间。initiateScene(sceneId) (初步实现):设置 currentState = 'PRESENTING_SCENE'。从GWHR获取当前场景ID和上下文。调用 LLMInterface.generate() 获取文本场景描述、NPC行为摘要、可选互动等。解析LLM响应，更新GWHR。调用 UIManager.displayScene() (此时无图像)。设置 currentState = 'AWAITING_PLAYER_ACTION'。processPlayerAction(actionType, actionDetail) (初步实现):设置 currentState = 'PROCESSING_ACTION'。根据 actionType 调用内部处理函数（初期可能仅为选择一个选项）。处理后，若场景变化则调用 initiateScene()，否则更新UI叙事部分。用户界面 (UIManager) 模块扩展:displayScene(description, choices, npcsInScene, interactiveElementsForMenu, environmentalEffects, detailedWeatherData, backgroundImageUrl): 初步实现，此时 backgroundImageUrl 为空，不显示图像区域。interactiveElementsForMenu 也可能为空或简单列表。displayNarrative(text): 更新叙事显示区域。GWHR 模块功能扩展:实现 logEvent(eventDescription, eventType, causalFactorsArray)。实现 logDialogue(speaker, utterance, npcId)。确保 World State 中包含 current_game_time。确保 Scene History & State 包含场景描述文本钩子和基础的互动元素列表。阶段 6: 图像生成集成与显示目标: 集成图像生成模型，根据文本场景描述动态生成并显示场景图像。详细任务:LLM接口 (LLMInterface) 模块扩展:实现 generateImage(imagePrompt, apiKey) 函数:针对 imagen-3.0-generate-002 模型。格式化 imagePrompt。处理API调用、响应解析（提取图像数据如base64字符串）、错误处理。返回图像数据或错误状态。GameController 模块功能增强:在 initiateScene 和 processPlayerAction 中：从文本LLM生成的场景描述和GWHR中提取关键视觉元素，构建 imagePrompt。在请求文本描述后，异步调用 LLMInterface.generateImage()。在收到图像后，更新GWHR中的 current_scene_image_url 和 current_scene_image_prompt_elements。用户界面 (UIManager) 模块增强:实现 showImageLoadingIndicator() 和 hideImageLoadingIndicator()。修改 displayScene():实现图像显示区域 (Image Display Area)。在请求图像时显示加载指示器。收到图像后，将其设置为背景。叙事区、选择区等作为图像上的覆盖层（例如，半透明框）。GWHR 模块数据结构更新:在 Scene History & State 中添加 current_scene_image_prompt_elements: string[] 和 current_scene_image_url: string。确保 updateState 能更新这些字段。阶段 7: UI增强 - 互动菜单与游戏系统菜单框架目标: 实现核心的“互动菜单”UI，并搭建“游戏系统菜单”的访问框架，提升交互便捷性。详细任务:用户界面 (UIManager) 模块核心UI元素实现:displayInteractionMenu(interactiveElementsList): 实现一个动态菜单，列出当前场景中所有可点击的互动元素（NPC、对象、谜题组件等）。showGameSystemsMenu(): 实现一个按钮或图标，用于打开/关闭一个专用的“游戏系统菜单”（此阶段仅为入口，具体内容后续填充）。调整主游戏界面布局，使其符合Galgame结构：图像显示区为主背景，叙事区叠加，侧边栏/区域放置场景信息、事件通知、时间显示和游戏系统菜单入口。GameController 模块逻辑调整:在 initiateScene 和 processPlayerAction 后，从GWHR获取当前场景的 availableInteractiveElements。调用 UIManager.displayInteractionMenu() 更新互动菜单。processPlayerAction 增加对 actionType: 'interact_via_menu' 的处理，actionDetail 包含被点击元素的信息。GWHR 模块数据结构更新:在 Scene History & State 中详细定义和更新 availableInteractiveElements 字段。此列表应由文本LLM根据场景上下文动态生成或由游戏逻辑判定。确保 getCurrentContext 能为LLM提供场景互动元素信息，以便LLM生成与菜单同步的描述。阶段 8: Agent（玩家）状态与基础成长系统目标: 建立Agent的核心状态（属性、技能、物品栏等）并实现基础的成长反馈机制。详细任务:GWHR 模块 Player State 详细定义:属性 (Attributes): 包括核心战斗/探索属性，以及精神属性如理智/意志力/洞察力。技能 (Skills): 结构化列表，包含技能等级、经验等（初始为空或有基础技能）。物品栏 (Inventory): 物品对象列表（名称、描述、数量等）。装备槽 (Equipment Slots): 定义各装备部位。当前位置 (currentLocation)。用户界面 (UIManager) 模块 - 游戏系统菜单内容初步填充:updatePlayerStatus(playerData): 从GWHR获取数据。实现“角色状态界面” (Character Status Interface) 的基本显示：属性、技能列表（可展开看详情）、当前装备（槽位和装备名）、物品栏快速访问按钮。实现“背包界面” (Backpack UI) 的基本显示：物品列表（图标、名称、数量）。实现“装备界面” (Equipment UI) 的基本显示：角色示意图或装备槽列表。GameController 模块基础成长逻辑:在 processPlayerAction 后，根据LLM的输出（例如，完成任务、成功使用技能的叙述）调用GWHR更新Agent经验或解锁新技能（LLM决定）。LLMInterface 模块交互调整:Prompt中加入Agent状态信息，以便LLM生成与Agent能力相符的叙事和结果。阶段 9: NPC互动与对话系统目标: 实现Agent与NPC的对话互动，NPC的响应应基于其个性和当前游戏状态。详细任务:GWHR 模块 NPC States 详细定义:每个NPC的属性、技能、与Agent的关系、知识、当前生命值、状态、位置、个性、动机、派系、临时状态等。Dialogue Log: 记录重要对话。GameController 模块NPC互动逻辑:handleFreeTextNPCInteraction(npcId, playerInput):从GWHR获取NPC状态和对话历史。构建prompt给文本LLM，包含上下文和Agent输入。LLM生成NPC对话内容和行为响应。更新GWHR（关系变化、信息揭露等）和对话日志。当通过“互动菜单”点击NPC时，触发对话流程。用户界面 (UIManager) 模块对话界面:displayNPCDialogue(npcId, text, clickableOptions): 显示NPC对话，以及LLM生成的选项式对话分支。提供自由文本输入框供Agent与NPC交流。LLMInterface 模块交互调整:Prompt需包含NPC的详细状态、个性、目标、与Agent的关系、近期独立活动摘要、对Agent行为的“学习”记录等，以生成更智能和一致的NPC响应。阶段 10: 战斗机制实现目标: 实现回合制或事件驱动的战斗系统，战斗过程和结果由LLM驱动。详细任务:GWHR 模块战斗相关数据结构:Combat Log: 详细记录战斗过程、策略、伤害计算、HP变化等。Agent和NPC状态中包含战斗相关属性（当前HP, maxHP, 攻击力, 防御力等）。GameController 模块战斗逻辑:initiateCombat(combatants):从GWHR提取参战者状态。构建初始战斗场景上下文给文本LLM。（可选）请求生成战斗特定背景图像或在现有场景图像上叠加战斗元素。processCombatTurn(playerChosenStrategy):将Agent策略和当前战斗状态发送给文本LLM。LLM决定回合结果，生成战斗描述，包括伤害值。游戏引擎根据LLM输出扣除HP。更新GWHR中的战斗状态和参战者状态。战斗结束条件判断（HP为0，投降等）。用户界面 (UIManager) 模块战斗界面:showCombatInterface(combatantsInfo): 清晰显示参战方及其HP（例如血条）。displayCombatNarrative(text): 显示战斗过程描述。updateCombatantsStatus(updates): 实时更新UI上的HP显示。presentCombatStrategies(strategies): 显示LLM生成的Agent可选战斗策略。showCombatResults(results): 显示战斗最终结果。LLMInterface 模块交互调整:Prompt需包含参战双方的详细状态、技能、装备、临时状态、环境因素、当前天气效果等。阶段 11: 环境谜题与调查系统目标: 实现场景内的环境谜题，Agent通过调查和互动来解决。详细任务:GWHR 模块谜题相关数据结构:EnvironmentalPuzzleLog: 记录谜题ID、状态、已发现线索、机关状态等。Scene History & State 中包含当前场景谜题元素的状态和可互动性。GameController 模块谜题处理逻辑:evaluateEnvironmentalPuzzleAction(puzzleId, playerActionOnElement, usedItem):当Agent通过“互动菜单”与谜题元素互动时调用。构建prompt给文本LLM，包含谜题状态、Agent行为、相关物品。LLM判断操作是否正确，生成结果描述和谜题状态更新。更新GWHR。用户界面 (UIManager) 模块谜题交互:“互动菜单”中应包含可操作的谜题组件。（可选）在“游戏系统菜单”中增加专门的“谜题界面” (Puzzle UI) 显示复杂谜题描述和线索。谜题解决的反馈通过叙事区显示。LLMInterface 模块交互调整:Prompt需包含谜题的设计逻辑（可能在世界生成时由LLM定义）、已发现线索、Agent的尝试操作等。expectedResponseType 可为 'environmental_puzzle_solution_eval'。阶段 12: 知识宝典与动态世界事件目标: 实现游戏内知识的收集与查阅系统，以及基于时间或Agent行为触发的动态世界事件。详细任务:GWHR 模块知识与事件数据结构:Knowledge Codex: 存储已解锁的知识条目（标题、内容、来源等）。DynamicWorldEventsLog: 记录已发生的动态世界事件及其影响。Event Log: 通用事件记录。GameController 模块知识与事件逻辑:unlockKnowledgeEntry(sourceType, sourceDetail): 根据Agent行为（阅读、对话、调查）判断是否解锁新知识，调用LLM生成条目内容。queryCodex(knowledgeId, userQuery): Agent查询知识宝典时，调用LLM基于已有条目回答。triggerDynamicEvent(eventId, isNpcDrivenFlag): 根据游戏逻辑或LLM判断触发动态事件，调用LLM生成事件描述、选项和影响。checkAndUpdateTimeBasedEvents(): 在时间推进时调用，检查是否触发时间相关的动态事件、NPC日程行为、天气变化等。用户界面 (UIManager) 模块知识与事件显示:“游戏系统菜单”中添加“知识宝典界面” (Knowledge Codex UI)。displayCodexQueryResult(answer): 显示查询结果。主界面侧边栏/区域显示动态事件的简要通知。动态天气系统初步实现:GWHR中World State加入currentWeather详细字段。LLM在生成场景描述时考虑当前天气，并叙述其视觉、听觉、触觉效果。checkAndUpdateTimeBasedEvents中加入天气变化逻辑（LLM判断或规则驱动）。阶段 13: 高级Agent与NPC系统目标: 实现更复杂的Agent与NPC交互系统，包括声望、派系、精神状态、临时状态及NPC的独立生活。详细任务:声望与派系系统 (Dynamic Reputation & Faction System):GWHR: PlayerFactionReputation (各派系声望值/等级/头衔), FactionDiplomacyMatrix (派系间外交关系)。LLM: 根据Agent行为评估声望变化，判断是否影响派系外交。UI: 角色状态界面显示派系声望。理智/意志力/洞察力系统 (Sanity/Willpower/Insight System):GWHR: MentalStateLog (记录精神属性值、影响事件、当前效果)。LLM: 根据特定事件评估对精神属性的影响，生成相关叙事和效果。UI: 角色状态界面显示精神属性及效果。临时状态系统 (Deep Fusion of Temporary States & Environmental Interaction):GWHR: TemporaryStateLog (记录角色当前临时状态的名称、来源、描述、效果、持续时间)。LLM: 根据环境、战斗、物品使用等赋予角色临时状态，并将其融入叙事。UI: 角色状态界面显示当前临时状态。NPC独立生活、目标与适应性学习系统 (NPC Independent Life, Goals & Adaptive Learning System):GWHR: NPC状态中加入 personalGoals (个人目标列表及进度), independentActivityLog (独立活动摘要), behavioralLearnings (对Agent行为的适应性调整记录), interNPCRelationships (NPC间的关系)。LLM: 模拟NPC在Agent视野外的活动和目标进展；根据与Agent的重复互动调整NPC行为；基于NPC目标或关系变化生成突发事件或任务线索。UI: NPC详情界面（若有）可选择性展示NPC当前活动摘要或对Agent的已知适应行为。GameController 和 LLMInterface 模块相应扩展，处理这些系统的逻辑和LLM交互。阶段 14: 制造、物品、装备、技能与任务系统完善目标: 全面实现制造、物品管理、装备、技能成长和结构化任务系统。详细任务:制造/物品组合系统 (Crafting/Item Combination):GameController: initiateCrafting(), processCraftingAttempt(materials)。LLM: 判断组合结果（成功、失败、意外发现），描述过程和结果，记录新配方。UI: “游戏系统菜单”中添加“制造界面” (Crafting UI)。GWHR: Crafting Log。Agent物品与背包系统 (Player Item & Backpack System):GWHR: Player State中inventory详细定义物品属性（耐久度、已解锁传说等）。LLM: 生成物品的独特描述、历史传说。UI: 完善“背包界面”，支持排序、筛选、物品交互（检视、使用、装备、丢弃等）。装备系统 (Equipment System):GWHR: Player State中equipmentSlots与物品关联。LLM: 描述装备的特殊能力、套装效果、外观变化、诅咒/祝福。UI: 完善“装备界面”，支持装备/卸下，显示属性变化。结构化能力/技能系统 (Structured Ability/Skill System):GWHR: Player State中skills详细定义（等级、经验、已解锁主动/被动能力）。LLM: 叙述技能学习、升级过程，描述主动能力效果。UI: “游戏系统菜单”中添加“技能界面” (Skills UI)，显示技能树或列表。结构化任务系统 (Structured Quest System):GWHR: Player State中activeQuests (QuestsLog) 详细定义（背景、目标、线索、期限、多解决路径、任务类型）。LLM: 生成任务背景、目标描述、线索提示，驱动多分支叙事，生成NPC驱动的突发任务。UI: “游戏系统菜单”中添加“任务日志界面” (Quest Log UI)。阶段 15: 潜行、非致命、经济、旅店、公会、地图与快速旅行系统目标: 实现高级游戏机制，为Agent提供更多样化的游戏方式和世界互动。详细任务:深度潜行与非致命解决系统 (In-depth Stealth & Non-Lethal Resolution System):GWHR: NPC状态加入alertLevel, isUnconscious, unconsciousDuration。StealthEventsLog。任务日志中resolutionPaths包含非致命选项。LLM: 评估潜行成功率、NPC警觉反应、非致命手段效果。UI: （可选）显示潜行相关信息，互动菜单提供潜行/非致命选项。动态经济与贸易系统 (Dynamic Economy & Trade System):GWHR: World State中加入regionalEconomyData (资源、供需、价格修正)。TradeLog。LLM: 根据世界事件、地区资源、Agent行为调整物品价格和稀缺度。生成商人库存和NPC贸易对话。UI: “游戏系统菜单”或NPC互动触发“贸易界面” (Trade Interface)。旅店与休憩系统 (Inn & Respite System):GWHR: 场景数据中记录旅店信息。Player State中currentRentedRoomInfo, storedItemsAtInns。LLM: 生成旅店特色、老板/顾客NPC对话、休息效果、特殊事件。UI: “游戏系统菜单”或互动菜单触发“旅店界面” (Inn UI)。冒险者公会系统 (Adventurer's Guild System):GWHR: World State中AdventurersGuilds列表。Player State中guildMemberships。LLM: 动态生成公会任务、关键NPC对话、公会氛围描述。UI: “游戏系统菜单”或互动菜单触发“公会界面” (Guild UI)。地图与快速旅行系统 (Map & Fast Travel System):GWHR: Player State中discoveredMapAreas, activatedFastTravelPoints, customMapMarkers。World State中worldMapDefinition, fastTravelNetwork。LLM: 生成地点发现、传送点激活、快速旅行过程的叙述。UI: “游戏系统菜单”中添加“地图界面” (Map UI)，显示已探索区域、传送点，支持点击快速旅行。互动菜单与地图发现同步。阶段 16: 世界演化、整体优化与Agent自我修正机制目标: 实现世界因Agent行为产生的长期演化，对所有系统进行调优，并为Agent引入自我修正能力。详细任务:世界演化与Agent印记系统 (World Evolution & Player Imprint System):GWHR: World State中加入playerImprints (记录Agent关键行为的长期影响)。LLM: 在特定时间点或Agent达成里程碑后，根据累积的playerImprints生成世界演化的描述，强调多系统联动效应。LLM Prompt 调优:针对所有文本和图像生成场景，迭代测试和优化LLM的prompt，以获得更佳、更一致、更有创意的输出。特别关注图像生成的审美和场景一致性。GWHR 结构与上下文逻辑优化:根据测试结果，调整GWHR的数据结构和 getCurrentContext 函数的摘要逻辑，优化LLM性能。优化 current_scene_image_url 和 current_scene_image_prompt_elements 的存储与检索。UI/UX 整体精炼:基于所有已实现系统，优化UI流程和信息展示，确保Agent能清晰理解所有动态系统，特别是互动菜单、游戏系统菜单和Galgame风格的图文呈现。错误处理增强:为所有API调用和核心游戏逻辑实现更健壮的错误处理机制（例如，请求重试、使用通用回退行为、记录详细错误日志、图像生成失败时显示占位符或提示）。Agent 自我修正机制 (概念):(此为高级目标，具体实现依赖Agent能力) 探索Agent在开发过程中根据测试反馈或预设指标，进行有限的自我代码调整或Prompt优化尝试。例如，Agent可以记录导致低质量LLM响应的Prompt模式，并尝试在后续生成中避免或修改它们。贯穿所有阶段的注意事项:模块化设计: 严格遵循模块化原则，确保各系统间低耦合、高内聚。GWHR的中心地位: 所有游戏状态的改变都必须准确、及时地反映在GWHR中。LLM的每次调用都必须基于GWHR提供的上下文。LLM交互的明确指示: 对LLM的prompt需要清晰、具体，明确指示其任务、期望的输出格式以及需要遵循的上下文信息。UI反馈的及时性与清晰度: Agent的任何操作、游戏世界的任何重要变化，都应在UI上有明确和及时的反馈，包括加载指示器。迭代开发与测试: 每个阶段完成后都应进行充分测试，以便尽早发现问题并进行调整。
